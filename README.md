##Описание задачи

Вам требуется реализовать демона, который будет обрабатывать сетевые подключения и выполнять поступающие в них команды.

Программа принимает один аргумент --- порт, на который она будет ожидать TCP-соединения. От каждого подключившегося клиента она считывает строку с командой, парсит команду и запускает её.

Команда --- это строка, заканчивающаяся символом перевода строки. Эту строку нужно разбить по символу "|" на подкоманды. Каждую подкоманду нужно разбить по пробелу на имя и аргументы, и запустить. Стандартный вывод первой подкоманды нужно перенаправить на стандартный ввод второй, стандартный вывод второй --- на стандартный ввод третьей, ... Стандартный ввод для первой подкоманды нужно забирать из сокета, стандартный вывод последней --- писать в сокет.

Сервер при запуске должен демонизоваться и записывать в текстовом виде свой pid в файл /tmp/netsh.pid.


##Пример использования

$ ./netsh 1234
$ echo 'ls' | socat STDIO TCP:localhost:1234
<содержимое директории>
$ echo "cat /proc/cpuinfo | grep 'model name' | sed -re 's/.*: (.*)/\1/' | uniq" | socat STDIO TCP:localhost:1234
<модель процессора>
$ (echo sh; cat) | socat STDIO TCP:localhost:1234
<sh, в котором можно выполнять команды удалённо>

##Технические детали

    Сервер должен уметь обрабатывать произвольное количество запросов одновременно, не зависая и отдавать данные клиенту сразу же, как они становятся доступны, вне завсимости от того, что происходит в остальных командах. Для удовлетворения этому требования, нужно делать мультиплексирование ввода-вывода при помощи epoll (не poll и не select).
    Весь ввод-вывод требуется реализовывать самостоятельно с помощью read и write.
    Код должен работать в одном потоке и создавать по новому процессу на каждую подкоманду.
    После того, как все подкоманды отработали, соединение с клиентом должно закрываться.
